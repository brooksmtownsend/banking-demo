// Generated by `wit-bindgen-wrpc-go` 0.8.0. DO NOT EDIT!
package resizer

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	io "io"
	slog "log/slog"
	math "math"
	sync "sync"
	atomic "sync/atomic"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

func Upload(ctx__ context.Context, wrpc__ wrpc.Invoker, body []uint8) (r0__ *wrpc.Result[string, string], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := func(v []uint8, w interface {
		io.ByteWriter
		io.Writer
	}) (write func(wrpc.IndexWriter) error, err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return nil, fmt.Errorf("list length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing list length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return nil, fmt.Errorf("failed to write list length of %d: %w", n, err)
		}
		slog.Debug("writing list elements")
		writes := make(map[uint32]func(wrpc.IndexWriter) error, n)
		for i, e := range v {
			write, err := (func(wrpc.IndexWriter) error)(nil), func(v uint8, w io.ByteWriter) error {
				slog.Debug("writing u8 byte")
				return w.WriteByte(v)
			}(e, w)
			if err != nil {
				return nil, fmt.Errorf("failed to write list element %d: %w", i, err)
			}
			if write != nil {
				writes[uint32(i)] = write
			}
		}
		if len(writes) > 0 {
			return func(w wrpc.IndexWriter) error {
				var wg sync.WaitGroup
				var wgErr atomic.Value
				for index, write := range writes {
					wg.Add(1)
					w, err := w.Index(index)
					if err != nil {
						return fmt.Errorf("failed to index writer: %w", err)
					}
					write := write
					go func() {
						defer wg.Done()
						if err := write(w); err != nil {
							wgErr.Store(err)
						}
					}()
				}
				wg.Wait()
				err := wgErr.Load()
				if err == nil {
					return nil
				}
				return err.(error)
			}, nil
		}
		return nil, nil
	}(body, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `body` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `body` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:image-processor/resizer@0.0.1", "upload", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `upload`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:image-processor/resizer@0.0.1", "name", "upload", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:image-processor/resizer@0.0.1", "name", "upload", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[string, string], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[string, string]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[string, string]{Err: &v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
func Resize(ctx__ context.Context, wrpc__ wrpc.Invoker, assetId string, width uint32, height uint32) (r0__ *wrpc.Result[string, string], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(assetId, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `asset-id` parameter: %w", err__)
		return
	}
	write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen32)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u32")
		_, err = w.Write(b[:i])
		return err
	}(width, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `width` parameter: %w", err__)
		return
	}
	write2__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v uint32, w io.Writer) (err error) {
		b := make([]byte, binary.MaxVarintLen32)
		i := binary.PutUvarint(b, uint64(v))
		slog.Debug("writing u32")
		_, err = w.Write(b[:i])
		return err
	}(height, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `height` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `asset-id` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `width` parameter")
		return
	}
	if write2__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `height` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:image-processor/resizer@0.0.1", "resize", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `resize`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:image-processor/resizer@0.0.1", "name", "resize", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:image-processor/resizer@0.0.1", "name", "resize", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[string, string], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[string, string]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[string, string]{Err: &v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
func Serve(ctx__ context.Context, wrpc__ wrpc.Invoker, assetId string) (r0__ *wrpc.Result[[]uint8, string], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(assetId, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `asset-id` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `asset-id` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:image-processor/resizer@0.0.1", "serve", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `serve`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:image-processor/resizer@0.0.1", "name", "serve", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:image-processor/resizer@0.0.1", "name", "serve", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[[]uint8, string], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) ([]byte, error) {
				var x uint32
				var s uint
				for i := 0; i < 5; i++ {
					slog.Debug("reading byte list length", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return nil, fmt.Errorf("failed to read byte list length byte: %w", err)
					}
					if b < 0x80 {
						if i == 4 && b > 1 {
							return nil, errors.New("byte list length overflows a 32-bit integer")
						}
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading byte list contents", "len", x)
						_, err = io.ReadFull(r, buf)
						if err != nil {
							return nil, fmt.Errorf("failed to read byte list contents: %w", err)
						}
						return buf, nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return nil, errors.New("byte length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[[]uint8, string]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[[]uint8, string]{Err: &v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
