// Generated by `wit-bindgen-wrpc-go` 0.8.0. DO NOT EDIT!
package tracker

import (
	bytes "bytes"
	context "context"
	binary "encoding/binary"
	errors "errors"
	fmt "fmt"
	demo__task_manager__types "github.com/cosmonic-labs/wasmcloud.space/providers/http-router/bindings/demo/task_manager/types"
	io "io"
	slog "log/slog"
	math "math"
	utf8 "unicode/utf8"
	wrpc "wrpc.io/go"
)

type Operation = demo__task_manager__types.Operation
type OperationError = demo__task_manager__types.OperationError

func Start(ctx__ context.Context, wrpc__ wrpc.Invoker, clientLocation string, originalAsset string) (r0__ *wrpc.Result[string, OperationError], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(clientLocation, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `client-location` parameter: %w", err__)
		return
	}
	write1__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(originalAsset, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `original-asset` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `client-location` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `original-asset` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:task-manager/tracker@0.0.1", "start", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `start`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:task-manager/tracker@0.0.1", "name", "start", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:task-manager/tracker@0.0.1", "name", "start", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[string, OperationError], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r interface {
				io.ByteReader
				io.Reader
			}) (string, error) {
				var x uint32
				var s uint8
				for i := 0; i < 5; i++ {
					slog.Debug("reading string length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return "", fmt.Errorf("failed to read string length byte: %w", err)
					}
					if s == 28 && b > 0x0f {
						return "", errors.New("string length overflows a 32-bit integer")
					}
					if b < 0x80 {
						x = x | uint32(b)<<s
						buf := make([]byte, x)
						slog.Debug("reading string bytes", "len", x)
						_, err = r.Read(buf)
						if err != nil {
							return "", fmt.Errorf("failed to read string bytes: %w", err)
						}
						if !utf8.Valid(buf) {
							return string(buf), errors.New("string is not valid UTF-8")
						}
						return string(buf), nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return "", errors.New("string length overflows a 32-bit integer")
			}(r)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[string, OperationError]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*OperationError, error) {
				v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.OperationError, error) {
					v := &demo__task_manager__types.OperationError{}
					var err error
					slog.Debug("reading field", "name", "message")
					v.Message, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `message` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*OperationError)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[string, OperationError]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
func Get(ctx__ context.Context, wrpc__ wrpc.Invoker, id string) (r0__ *wrpc.Result[Operation, OperationError], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(id, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `id` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `id` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:task-manager/tracker@0.0.1", "get", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `get`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:task-manager/tracker@0.0.1", "name", "get", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:task-manager/tracker@0.0.1", "name", "get", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[Operation, OperationError], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func() (*Operation, error) {
				v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.Operation, error) {
					v := &demo__task_manager__types.Operation{}
					var err error
					slog.Debug("reading field", "name", "id")
					v.Id, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `id` field: %w", err)
					}
					slog.Debug("reading field", "name", "original-asset")
					v.OriginalAsset, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `original-asset` field: %w", err)
					}
					slog.Debug("reading field", "name", "client-location")
					v.ClientLocation, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `client-location` field: %w", err)
					}
					slog.Debug("reading field", "name", "created-at")
					v.CreatedAt, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
						slog.Debug("reading string length byte", "i", i)
						b, err := r.ReadByte()
						if err != nil {
							if i > 0 && err == io.EOF {
								err = io.ErrUnexpectedEOF
							}
							return "", fmt.Errorf("failed to read string length byte: %w", err)
						}
						if s == 28 && b > 0x0f {
							return "", errors.New("string length overflows a 32-bit integer")
						}
						if b < 0x80 {
							x = x | uint32(b)<<s
							buf := make([]byte, x)
							slog.Debug("reading string bytes", "len", x)
							_, err = r.Read(buf)
							if err != nil {
								return "", fmt.Errorf("failed to read string bytes: %w", err)
							}
							if !utf8.Valid(buf) {
								return string(buf), errors.New("string is not valid UTF-8")
							}
							return string(buf), nil
						}
						x |= uint32(b&0x7f) << s
						s += 7
					}; return "", errors.New("string length overflows a 32-bit integer") }(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `created-at` field: %w", err)
					}
					slog.Debug("reading field", "name", "resized-asset")
					v.ResizedAsset, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 4)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `resized-asset` field: %w", err)
					}
					slog.Debug("reading field", "name", "resize-error")
					v.ResizeError, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 5)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `resize-error` field: %w", err)
					}
					slog.Debug("reading field", "name", "resized-at")
					v.ResizedAt, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 6)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `resized-at` field: %w", err)
					}
					slog.Debug("reading field", "name", "analyze-result")
					v.AnalyzeResult, err = func(r wrpc.IndexReader, path ...uint32) (*bool, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r io.ByteReader) (bool, error) {
								slog.Debug("reading bool byte")
								v, err := r.ReadByte()
								if err != nil {
									slog.Debug("reading bool", "value", false)
									return false, fmt.Errorf("failed to read bool byte: %w", err)
								}
								switch v {
								case 0:
									return false, nil
								case 1:
									return true, nil
								default:
									return false, fmt.Errorf("invalid bool value %d", v)
								}
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 7)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `analyze-result` field: %w", err)
					}
					slog.Debug("reading field", "name", "analyze-error")
					v.AnalyzeError, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 8)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `analyze-error` field: %w", err)
					}
					slog.Debug("reading field", "name", "analyzed-at")
					v.AnalyzedAt, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
						slog.Debug("reading option status byte")
						status, err := r.ReadByte()
						if err != nil {
							return nil, fmt.Errorf("failed to read option status byte: %w", err)
						}
						switch status {
						case 0:
							return nil, nil
						case 1:
							slog.Debug("reading `option::some` payload")
							v, err := func(r interface {
								io.ByteReader
								io.Reader
							}) (string, error) {
								var x uint32
								var s uint8
								for i := 0; i < 5; i++ {
									slog.Debug("reading string length byte", "i", i)
									b, err := r.ReadByte()
									if err != nil {
										if i > 0 && err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										return "", fmt.Errorf("failed to read string length byte: %w", err)
									}
									if s == 28 && b > 0x0f {
										return "", errors.New("string length overflows a 32-bit integer")
									}
									if b < 0x80 {
										x = x | uint32(b)<<s
										buf := make([]byte, x)
										slog.Debug("reading string bytes", "len", x)
										_, err = r.Read(buf)
										if err != nil {
											return "", fmt.Errorf("failed to read string bytes: %w", err)
										}
										if !utf8.Valid(buf) {
											return string(buf), errors.New("string is not valid UTF-8")
										}
										return string(buf), nil
									}
									x |= uint32(b&0x7f) << s
									s += 7
								}
								return "", errors.New("string length overflows a 32-bit integer")
							}(r)
							if err != nil {
								return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
							}
							return &v, nil
						default:
							return nil, fmt.Errorf("invalid option status byte %d", status)
						}
					}(r, append(path, 9)...)
					if err != nil {
						return nil, fmt.Errorf("failed to read `analyzed-at` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*Operation)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[Operation, OperationError]{Ok: v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*OperationError, error) {
				v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.OperationError, error) {
					v := &demo__task_manager__types.OperationError{}
					var err error
					slog.Debug("reading field", "name", "message")
					v.Message, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `message` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*OperationError)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[Operation, OperationError]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
func CompleteResize(ctx__ context.Context, wrpc__ wrpc.Invoker, id string, resizedAsset *string, resizeError *string) (r0__ *wrpc.Result[struct{}, OperationError], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(id, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `id` parameter: %w", err__)
		return
	}
	write1__, err__ := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(resizedAsset, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `resized-asset` parameter: %w", err__)
		return
	}
	write2__, err__ := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(resizeError, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `resize-error` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `id` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `resized-asset` parameter")
		return
	}
	if write2__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `resize-error` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:task-manager/tracker@0.0.1", "complete-resize", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `complete-resize`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:task-manager/tracker@0.0.1", "name", "complete-resize", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:task-manager/tracker@0.0.1", "name", "complete-resize", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, OperationError], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			var v struct{}
			return &wrpc.Result[struct{}, OperationError]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*OperationError, error) {
				v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.OperationError, error) {
					v := &demo__task_manager__types.OperationError{}
					var err error
					slog.Debug("reading field", "name", "message")
					v.Message, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `message` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*OperationError)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[struct{}, OperationError]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
func CompleteAnalyze(ctx__ context.Context, wrpc__ wrpc.Invoker, id string, detected *bool, analyzeError *string) (r0__ *wrpc.Result[struct{}, OperationError], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(id, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `id` parameter: %w", err__)
		return
	}
	write1__, err__ := func(v *bool, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v bool, w io.ByteWriter) error {
			if !v {
				slog.Debug("writing `false` byte")
				return w.WriteByte(0)
			}
			slog.Debug("writing `true` byte")
			return w.WriteByte(1)
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(detected, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `detected` parameter: %w", err__)
		return
	}
	write2__, err__ := func(v *string, w interface {
		io.ByteWriter
		io.Writer
	}) (func(wrpc.IndexWriter) error, error) {
		if v == nil {
			slog.Debug("writing `option::none` status byte")
			if err := w.WriteByte(0); err != nil {
				return nil, fmt.Errorf("failed to write `option::none` byte: %w", err)
			}
			return nil, nil
		}
		slog.Debug("writing `option::some` status byte")
		if err := w.WriteByte(1); err != nil {
			return nil, fmt.Errorf("failed to write `option::some` status byte: %w", err)
		}
		slog.Debug("writing `option::some` payload")
		write, err := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
			n := len(v)
			if n > math.MaxUint32 {
				return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
			}
			if err = func(v int, w io.Writer) error {
				b := make([]byte, binary.MaxVarintLen32)
				i := binary.PutUvarint(b, uint64(v))
				slog.Debug("writing string byte length", "len", n)
				_, err = w.Write(b[:i])
				return err
			}(n, w); err != nil {
				return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
			}
			slog.Debug("writing string bytes")
			_, err = w.Write([]byte(v))
			if err != nil {
				return fmt.Errorf("failed to write string bytes: %w", err)
			}
			return nil
		}(*v, w)
		if err != nil {
			return nil, fmt.Errorf("failed to write `option::some` payload: %w", err)
		}
		return write, nil
	}(analyzeError, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `analyze-error` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `id` parameter")
		return
	}
	if write1__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `detected` parameter")
		return
	}
	if write2__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `analyze-error` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:task-manager/tracker@0.0.1", "complete-analyze", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `complete-analyze`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:task-manager/tracker@0.0.1", "name", "complete-analyze", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:task-manager/tracker@0.0.1", "name", "complete-analyze", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, OperationError], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			var v struct{}
			return &wrpc.Result[struct{}, OperationError]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*OperationError, error) {
				v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.OperationError, error) {
					v := &demo__task_manager__types.OperationError{}
					var err error
					slog.Debug("reading field", "name", "message")
					v.Message, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `message` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*OperationError)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[struct{}, OperationError]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
func List(ctx__ context.Context, wrpc__ wrpc.Invoker) (r0__ *wrpc.Result[[]*demo__task_manager__types.Operation, OperationError], err__ error) {
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:task-manager/tracker@0.0.1", "list", nil)
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `list`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:task-manager/tracker@0.0.1", "name", "list", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:task-manager/tracker@0.0.1", "name", "list", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[[]*demo__task_manager__types.Operation, OperationError], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			slog.Debug("reading `result::ok` payload")
			v, err := func(r wrpc.IndexReader, path ...uint32) ([]*demo__task_manager__types.Operation, error) {
				var x uint32
				var s uint
				for i := 0; i < 5; i++ {
					slog.Debug("reading list length byte", "i", i)
					b, err := r.ReadByte()
					if err != nil {
						if i > 0 && err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						return nil, fmt.Errorf("failed to read list length byte: %w", err)
					}
					if b < 0x80 {
						if i == 4 && b > 1 {
							return nil, errors.New("list length overflows a 32-bit integer")
						}
						x = x | uint32(b)<<s
						vs := make([]*demo__task_manager__types.Operation, x)
						for i := range vs {
							slog.Debug("reading list element", "i", i)
							vs[i], err = func() (*Operation, error) {
								v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.Operation, error) {
									v := &demo__task_manager__types.Operation{}
									var err error
									slog.Debug("reading field", "name", "id")
									v.Id, err = func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) {
										var x uint32
										var s uint8
										for i := 0; i < 5; i++ {
											slog.Debug("reading string length byte", "i", i)
											b, err := r.ReadByte()
											if err != nil {
												if i > 0 && err == io.EOF {
													err = io.ErrUnexpectedEOF
												}
												return "", fmt.Errorf("failed to read string length byte: %w", err)
											}
											if s == 28 && b > 0x0f {
												return "", errors.New("string length overflows a 32-bit integer")
											}
											if b < 0x80 {
												x = x | uint32(b)<<s
												buf := make([]byte, x)
												slog.Debug("reading string bytes", "len", x)
												_, err = r.Read(buf)
												if err != nil {
													return "", fmt.Errorf("failed to read string bytes: %w", err)
												}
												if !utf8.Valid(buf) {
													return string(buf), errors.New("string is not valid UTF-8")
												}
												return string(buf), nil
											}
											x |= uint32(b&0x7f) << s
											s += 7
										}
										return "", errors.New("string length overflows a 32-bit integer")
									}(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `id` field: %w", err)
									}
									slog.Debug("reading field", "name", "original-asset")
									v.OriginalAsset, err = func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if s == 28 && b > 0x0f {
											return "", errors.New("string length overflows a 32-bit integer")
										}
										if b < 0x80 {
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}; return "", errors.New("string length overflows a 32-bit integer") }(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `original-asset` field: %w", err)
									}
									slog.Debug("reading field", "name", "client-location")
									v.ClientLocation, err = func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if s == 28 && b > 0x0f {
											return "", errors.New("string length overflows a 32-bit integer")
										}
										if b < 0x80 {
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}; return "", errors.New("string length overflows a 32-bit integer") }(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `client-location` field: %w", err)
									}
									slog.Debug("reading field", "name", "created-at")
									v.CreatedAt, err = func(r interface {
										io.ByteReader
										io.Reader
									}) (string, error) { var x uint32; var s uint8; for i := 0; i < 5; i++ {
										slog.Debug("reading string length byte", "i", i)
										b, err := r.ReadByte()
										if err != nil {
											if i > 0 && err == io.EOF {
												err = io.ErrUnexpectedEOF
											}
											return "", fmt.Errorf("failed to read string length byte: %w", err)
										}
										if s == 28 && b > 0x0f {
											return "", errors.New("string length overflows a 32-bit integer")
										}
										if b < 0x80 {
											x = x | uint32(b)<<s
											buf := make([]byte, x)
											slog.Debug("reading string bytes", "len", x)
											_, err = r.Read(buf)
											if err != nil {
												return "", fmt.Errorf("failed to read string bytes: %w", err)
											}
											if !utf8.Valid(buf) {
												return string(buf), errors.New("string is not valid UTF-8")
											}
											return string(buf), nil
										}
										x |= uint32(b&0x7f) << s
										s += 7
									}; return "", errors.New("string length overflows a 32-bit integer") }(r)
									if err != nil {
										return nil, fmt.Errorf("failed to read `created-at` field: %w", err)
									}
									slog.Debug("reading field", "name", "resized-asset")
									v.ResizedAsset, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 4)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `resized-asset` field: %w", err)
									}
									slog.Debug("reading field", "name", "resize-error")
									v.ResizeError, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 5)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `resize-error` field: %w", err)
									}
									slog.Debug("reading field", "name", "resized-at")
									v.ResizedAt, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 6)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `resized-at` field: %w", err)
									}
									slog.Debug("reading field", "name", "analyze-result")
									v.AnalyzeResult, err = func(r wrpc.IndexReader, path ...uint32) (*bool, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r io.ByteReader) (bool, error) {
												slog.Debug("reading bool byte")
												v, err := r.ReadByte()
												if err != nil {
													slog.Debug("reading bool", "value", false)
													return false, fmt.Errorf("failed to read bool byte: %w", err)
												}
												switch v {
												case 0:
													return false, nil
												case 1:
													return true, nil
												default:
													return false, fmt.Errorf("invalid bool value %d", v)
												}
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 7)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `analyze-result` field: %w", err)
									}
									slog.Debug("reading field", "name", "analyze-error")
									v.AnalyzeError, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 8)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `analyze-error` field: %w", err)
									}
									slog.Debug("reading field", "name", "analyzed-at")
									v.AnalyzedAt, err = func(r wrpc.IndexReader, path ...uint32) (*string, error) {
										slog.Debug("reading option status byte")
										status, err := r.ReadByte()
										if err != nil {
											return nil, fmt.Errorf("failed to read option status byte: %w", err)
										}
										switch status {
										case 0:
											return nil, nil
										case 1:
											slog.Debug("reading `option::some` payload")
											v, err := func(r interface {
												io.ByteReader
												io.Reader
											}) (string, error) {
												var x uint32
												var s uint8
												for i := 0; i < 5; i++ {
													slog.Debug("reading string length byte", "i", i)
													b, err := r.ReadByte()
													if err != nil {
														if i > 0 && err == io.EOF {
															err = io.ErrUnexpectedEOF
														}
														return "", fmt.Errorf("failed to read string length byte: %w", err)
													}
													if s == 28 && b > 0x0f {
														return "", errors.New("string length overflows a 32-bit integer")
													}
													if b < 0x80 {
														x = x | uint32(b)<<s
														buf := make([]byte, x)
														slog.Debug("reading string bytes", "len", x)
														_, err = r.Read(buf)
														if err != nil {
															return "", fmt.Errorf("failed to read string bytes: %w", err)
														}
														if !utf8.Valid(buf) {
															return string(buf), errors.New("string is not valid UTF-8")
														}
														return string(buf), nil
													}
													x |= uint32(b&0x7f) << s
													s += 7
												}
												return "", errors.New("string length overflows a 32-bit integer")
											}(r)
											if err != nil {
												return nil, fmt.Errorf("failed to read `option::some` value: %w", err)
											}
											return &v, nil
										default:
											return nil, fmt.Errorf("invalid option status byte %d", status)
										}
									}(r, append(path, 9)...)
									if err != nil {
										return nil, fmt.Errorf("failed to read `analyzed-at` field: %w", err)
									}
									return v, nil
								}(r, append(path, uint32(i))...)
								return (*Operation)(v), err
							}()

							if err != nil {
								return nil, fmt.Errorf("failed to read list element %d: %w", i, err)
							}
						}
						return vs, nil
					}
					x |= uint32(b&0x7f) << s
					s += 7
				}
				return nil, errors.New("list length overflows a 32-bit integer")
			}(r, path...)
			if err != nil {
				return nil, fmt.Errorf("failed to read `result::ok` value: %w", err)
			}
			return &wrpc.Result[[]*demo__task_manager__types.Operation, OperationError]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*OperationError, error) {
				v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.OperationError, error) {
					v := &demo__task_manager__types.OperationError{}
					var err error
					slog.Debug("reading field", "name", "message")
					v.Message, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `message` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*OperationError)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[[]*demo__task_manager__types.Operation, OperationError]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
func Delete(ctx__ context.Context, wrpc__ wrpc.Invoker, id string) (r0__ *wrpc.Result[struct{}, OperationError], err__ error) {
	var buf__ bytes.Buffer
	write0__, err__ := (func(wrpc.IndexWriter) error)(nil), func(v string, w io.Writer) (err error) {
		n := len(v)
		if n > math.MaxUint32 {
			return fmt.Errorf("string byte length of %d overflows a 32-bit integer", n)
		}
		if err = func(v int, w io.Writer) error {
			b := make([]byte, binary.MaxVarintLen32)
			i := binary.PutUvarint(b, uint64(v))
			slog.Debug("writing string byte length", "len", n)
			_, err = w.Write(b[:i])
			return err
		}(n, w); err != nil {
			return fmt.Errorf("failed to write string byte length of %d: %w", n, err)
		}
		slog.Debug("writing string bytes")
		_, err = w.Write([]byte(v))
		if err != nil {
			return fmt.Errorf("failed to write string bytes: %w", err)
		}
		return nil
	}(id, &buf__)
	if err__ != nil {
		err__ = fmt.Errorf("failed to write `id` parameter: %w", err__)
		return
	}
	if write0__ != nil {
		err__ = errors.New("unexpected deferred write for synchronous `id` parameter")
		return
	}
	var w__ wrpc.IndexWriteCloser
	var r__ wrpc.IndexReadCloser
	w__, r__, err__ = wrpc__.Invoke(ctx__, "demo:task-manager/tracker@0.0.1", "delete", buf__.Bytes())
	if err__ != nil {
		err__ = fmt.Errorf("failed to invoke `delete`: %w", err__)
		return
	}
	defer func() {
		if err := r__.Close(); err != nil {
			slog.ErrorContext(ctx__, "failed to close reader", "instance", "demo:task-manager/tracker@0.0.1", "name", "delete", "err", err)
		}
	}()
	if cErr__ := w__.Close(); cErr__ != nil {
		slog.DebugContext(ctx__, "failed to close outgoing stream", "instance", "demo:task-manager/tracker@0.0.1", "name", "delete", "err", cErr__)
	}
	r0__, err__ = func(r wrpc.IndexReader, path ...uint32) (*wrpc.Result[struct{}, OperationError], error) {
		slog.Debug("reading result status byte")
		status, err := r.ReadByte()
		if err != nil {
			return nil, fmt.Errorf("failed to read result status byte: %w", err)
		}
		switch status {
		case 0:
			var v struct{}
			return &wrpc.Result[struct{}, OperationError]{Ok: &v}, nil
		case 1:
			slog.Debug("reading `result::err` payload")
			v, err := func() (*OperationError, error) {
				v, err := func(r wrpc.IndexReader, path ...uint32) (*demo__task_manager__types.OperationError, error) {
					v := &demo__task_manager__types.OperationError{}
					var err error
					slog.Debug("reading field", "name", "message")
					v.Message, err = func(r interface {
						io.ByteReader
						io.Reader
					}) (string, error) {
						var x uint32
						var s uint8
						for i := 0; i < 5; i++ {
							slog.Debug("reading string length byte", "i", i)
							b, err := r.ReadByte()
							if err != nil {
								if i > 0 && err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								return "", fmt.Errorf("failed to read string length byte: %w", err)
							}
							if s == 28 && b > 0x0f {
								return "", errors.New("string length overflows a 32-bit integer")
							}
							if b < 0x80 {
								x = x | uint32(b)<<s
								buf := make([]byte, x)
								slog.Debug("reading string bytes", "len", x)
								_, err = r.Read(buf)
								if err != nil {
									return "", fmt.Errorf("failed to read string bytes: %w", err)
								}
								if !utf8.Valid(buf) {
									return string(buf), errors.New("string is not valid UTF-8")
								}
								return string(buf), nil
							}
							x |= uint32(b&0x7f) << s
							s += 7
						}
						return "", errors.New("string length overflows a 32-bit integer")
					}(r)
					if err != nil {
						return nil, fmt.Errorf("failed to read `message` field: %w", err)
					}
					return v, nil
				}(r, path...)
				return (*OperationError)(v), err
			}()

			if err != nil {
				return nil, fmt.Errorf("failed to read `result::err` value: %w", err)
			}
			return &wrpc.Result[struct{}, OperationError]{Err: v}, nil
		default:
			return nil, fmt.Errorf("invalid result status byte %d", status)
		}
	}(r__, []uint32{0}...)
	if err__ != nil {
		err__ = fmt.Errorf("failed to read result 0: %w", err__)
		return
	}
	return
}
